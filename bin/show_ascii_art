#!/bin/bash
#
ART_DIR="/usr/share/doc/asciiville/art"
FIG_WELCOME="Welcome To"
FIG_ASCII="Asciiville"
FIG_FONTS="/usr/share/figlet-fonts"
LARGE_FONT="Bolger"
SMALL_FONT="Small"
MUSEDIR=/usr/share/doc/asciiville/music
SONG="${MUSEDIR}/Chronos.mp3"
ALTSONG="${MUSEDIR}/Epic_Dramatic-Yuriy_Bespalov.wav"
art="yinyang"

# Default palette used by jp2a
defchars="   ...',;:clodxkO0KXNWM"
# Reversed default palette
revchars="MWNXK0Okxdolc:;,'...   "
# Dark to light character set
revlong="8WMoahkbdpqwmZO0QLCJUYXzcvunxrjft1-_+ilI;:,^..."
# Light to Dark character set
longchars="...^,:;Ili+_-1tfjrxnuvczXYUJCLQ0OZmwqpdbkhaoMW8"

set -m

usage() {
  printf "\nUsage: show_ascii_art [-a art] [-A art_dir] [-b] [-B] [-c] [-C]"
  printf "\n\t[-d font_dir] [-D seconds] [-F large_font] [-f small_font] [-g]"
  printf "\n\t[-i image] [-l] [-L] [-n tabs] [-N depth] [-o] [-p palette]"
  printf "\n\t[-P] [-q] [-r] [-s show] [-S] [-u] [-t first_text]"
  printf "\n\t[-T second_text] [-h height] [-w width]"
  printf "\nWhere:"
  printf "\n\t-a 'art' specifies which ascii art to display"
  printf "\n\t-A 'art_dir' specifies the path to the ascii art folder"
  printf "\n\t-b when generating ascii art use a border"
  printf "\n\t-B use backup song when playing audio in slideshows"
  printf "\n\t-c when generating ascii art use ANSI colors"
  printf "\n\t-C center ascii art on screen if border detected"
  printf "\n\t-d 'font_dir' specifies the path to the figlet fonts"
  printf "\n\t-D 'seconds' specifies the delay, in seconds, between screens"
  printf "\n\t-g convert image to grayscale"
  printf "\n\t-i 'image' specifies an image file to convert to ascii art"
  printf "\n\t-l use lolcat coloring"
  printf "\n\t-L lists the ascii art in the 'art_dir' and exits"
  printf "\n\t-f 'small_font' specifies the figlet font to use for small text"
  printf "\n\t-F 'large_font' specifies the figlet font to use for large text"
  printf "\n\t-n 'tabs' specifies the number of tabs to indent image display"
  printf "\n\t-N 'depth' specifies the color depth"
  printf "\n\t\t'depth' can be '4' (for ANSI), '8' (for 256 color palette)"
  printf "\n\t\tor '24' (for truecolor or 24-bit color)"
  printf "\n\t-o indicates overwrite any existing ascii art when saving"
  printf "\n\t-P indicates play audio during slideshow"
  printf "\n\t-p 'palette' specifies which character set to use for ascii art"
  printf "\n\t\t'palette' can be one of 'def', 'long', 'rev', 'longrev'"
  printf "\n\t\t'def' is the default set, 'long' a long set,"
  printf "\n\t\t'rev' reverses default, 'longrev' reverses long"
  printf "\n\t\tAny other argument to '-p' will be taken as the character set"
  printf "\n\t-q don't display text, just the ascii art"
  printf "\n\t-r indicates select random fonts"
  printf "\n\t-s 'show' slide show of ascii art"
  printf "\n\t\t'show' can be Art, Fractals, Lyap, Owls, Waterfalls, Mixed"
  printf "\n\t-S indicates save converted image ascii art in art_dir"
  printf "\n\t-t 'first_text' specifies the first text to display"
  printf "\n\t-T 'second_text' specifies the second text to display"
  printf "\n\t-u displays this usage message and exits"
  printf "\n\t-h 'height' specifies the height of the converted ascii art"
  printf "\n\t-w 'width' specifies the width of the converted ascii art"
  printf "\n\t\tIf only one of 'width' and 'height' is provided,"
  printf "\n\t\tcalculate the other from image aspect ratio\n\n"
  exit 1
}

set_spaces() {
  space=0
  while [ ${space} -lt ${numspaces} ]
  do
    spaces="${spaces} "
    ((space++))
  done
}

set_tabs() {
  tab=0
  while [ ${tab} -lt ${numtabs} ]
  do
    tabs="${tabs}\t"
    ((tab++))
  done
}

# Display the ascii art
#   first argument is the file
#   second argument is prepended on each line of output (e.g. "\t\t")
#   third is a command to use in a pipe (optional)
show_ascii() {
  [ -f "$1" ] || {
    echo "File: $1 does not exist"
    echo "Exiting"
    exit 1
  }

  prep="\n${2}"
  numlines=0
  [ "${center}" ] && {
    firstline=`head -1 $1`
    echo "${firstline}" | grep "^+-------" > /dev/null && {
      # ascii art with boundary, we know its width
      awide=`echo "${firstline}" | wc -c`
      ahigh=`cat "$1" | wc -l`
      h_margin="$((termwide - awide))"
      [ ${h_margin} -lt 0 ] && return 3
      v_margin="$((termhigh - ahigh))"
      if [ ${h_margin} -gt 1 ]
      then
        numspaces="$((h_margin / 2))"
      else
        numspaces=0
      fi
      spaces=
      set_spaces
      prep="\n${spaces}"
      if [ ${v_margin} -gt 1 ]
      then
        numlines="$((v_margin / 2))"
      else
        numlines=0
      fi
    }
  }

  line=0
  while [ ${line} -lt ${numlines} ]
  do
    printf "\n"
    ((line++))
  done
  if [ "$3" ]
  then
    # /bin/cat "$1" | while read l
    # do
    #   printf "${prep}$l"
    # done | $3
    while read l
    do 
      printf "${prep}$l"
    done < <(/bin/cat "$1") | $3
  else
    # /bin/cat "$1" | while read l
    # do
    #   printf "${prep}$l"
    # done
    while read l
    do 
      printf "${prep}$l"
    done < <(/bin/cat "$1")
  fi
  printf "\n"
}

audio=
border=
center=
charopt=
colordepth=
colors=
grayscale=
list=
lolcat=
quiet=
delay=5
input_image=
randfont=
overwrite=
save_art=
height=
numtabs=0
slideshow=
tabs=
width=
have_convert=`type -p convert`
have_jp2a=`type -p jp2a`
while getopts "a:A:bBcCD:d:gh:i:lLF:f:n:N:oPp:qrs:St:T:w:u" flag; do
  case $flag in
      a)
          art="${OPTARG}"
          ;;
      A)
          ART_DIR="${OPTARG}"
          ;;
      b)
          border="--border"
          ;;
      B)
          SONG="${ALTSONG}"
          ;;
      c)
          colors="--colors"
          ;;
      C)
          center=1
          ;;
      d)
          FIG_FONTS="${OPTARG}"
          ;;
      D)
          delay="${OPTARG}"
          ;;
      F)
          LARGE_FONT="${OPTARG}"
          ;;
      f)
          SMALL_FONT="${OPTARG}"
          ;;
      g)
          grayscale="--grayscale"
          ;;
      i)
          if [ "${have_jp2a}" ]
          then
            input_image="${OPTARG}"
          else
            echo "The jp2a command not installed or not in PATH"
            echo "Skipping conversion and using default ascii art"
          fi
          ;;
      L)
          list=1
          ;;
      l)
          lolcat=1
          ;;
      n)
          numtabs=${OPTARG}
          ;;
      N)
          colordepth="--color-depth=${OPTARG}"
          ;;
      o)
          overwrite=1
          ;;
      P)
          audio=1
          ;;
      p)
          charset="${OPTARG}"
          case "${charset}" in
            def)
              charopt=
              ;;
            long)
              charopt="--chars=${longchars}"
              ;;
            rev)
              charopt="--chars=${revchars}"
              ;;
            longrev)
              charopt="--chars=${revlong}"
              ;;
            *)
              charopt="--chars=${charset}"
              ;;
          esac
          ;;
      q)
          quiet=1
          ;;
      r)
          randfont=1
          ;;
      s)
          slideshow="${OPTARG}"
          ;;
      S)
          save_art=1
          ;;
      t)
          FIG_WELCOME="${OPTARG}"
          ;;
      T)
          FIG_ASCII="${OPTARG}"
          ;;
      h)
          height="${OPTARG}"
          ;;
      w)
          width="${OPTARG}"
          ;;
      u)
          usage
          ;;
  esac
done

[ "${list}" ] && {
  first=1
  for art in ${ART_DIR}/*.txt
  do
      [ "${art}" == "${ART_DIR}/*.txt" ] && {
          echo "No ascii art found in ${ART_DIR}"
          echo "Ascii art files must have a '.txt' suffix"
          exit 0
      }
      [ "${first}" ] && echo "Ascii Art in ${ART_DIR} :"
      bart=`basename "${art}"`
      name=`echo ${bart} | sed -e "s/.txt//"`
      printf "\n\t${name}"
      first=
  done
  printf "\n\n"
  exit 0
}

have_lolcat=
[ "${lolcat}" ] && {
  have_lolcat=`type -p lolcat`
}

sleep 2
termwide=`stty size | awk '{print $2}'`
termhigh=`stty size | awk '{print $1}'`

fade_audio() {
  vol=75
  while [ ${vol} -gt 0 ]
  do
    echo "volume ${vol} 1" > ${fifo}
    vol=$((vol - 5))
    sleep 0.1
  done
  echo "stop" > ${fifo}
  sleep 0.1
  echo "quit" > ${fifo}
  rm -f ${fifo}
}

cleanup() {
  tput cnorm
  [ "${playing}" ] && fade_audio
  exit 0
}

[ "${slideshow}" ] && {
  stty -echoctl # hide ^C
  trap 'cleanup' SIGINT SIGTERM
  FIG_WELCOME="Asciiville"
  case "${slideshow}" in
    Art*)
      FIG_ASCII="Fine Art"
      SLIDE_DIR="${ART_DIR}/Art"
      SLIDE_FONT="Shadow"
      ;;
    Fractal*)
      FIG_ASCII="Fractal"
      SLIDE_DIR="${ART_DIR}/Fractals"
      SLIDE_FONT="sblood"
      ;;
    Lyap*)
      FIG_ASCII="Lyapunov"
      SLIDE_DIR="${ART_DIR}/Lyapunov"
      SLIDE_FONT="3d"
      ;;
    Owls*)
      FIG_ASCII="Owls"
      SLIDE_DIR="${ART_DIR}/Owls"
      SLIDE_FONT="ANSI Shadow"
      ;;
    Waterfall*)
      FIG_ASCII="Waterfalls"
      SLIDE_DIR="${ART_DIR}/Waterfalls"
      SLIDE_FONT="Bolger"
      ;;
    *)
      FIG_ASCII="Mixed"
      SLIDE_DIR="${ART_DIR}"
      SLIDE_FONT="Varsity"
      ;;
  esac

  playing=
  [ "${audio}" ] && {
    have_mplayer=`type -p mplayer`
    [ "${have_mplayer}" ] && {
      fifo="/tmp/mplayer$$"
      rm -f ${fifo}
      mkfifo ${fifo}
      playing=1
      mplayer -novideo -loop 0 -volume 80 -really-quiet \
              -nolirc -slave -input file=${fifo} ${SONG} 2>&1 &
    }
  }
  clear
  first=1
  tput civis
  for art in ${SLIDE_DIR}/*.txt
  do
    [ "${art}" == "${SLIDE_DIR}/*.txt" ] && {
      echo "No ascii art found in ${SLIDE_DIR}"
      echo "Ascii art files must have a '.txt' suffix"
      exit 0
    }
    [ "${first}" ] && {
      [ "${quiet}" ] || {
        printf "\n\n\n\n"
        if [ "${have_lolcat}" ]
        then
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t ${FIG_WELCOME} | lolcat
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t ${FIG_ASCII} | lolcat
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Ascii Art" | lolcat
        else
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t ${FIG_WELCOME}
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t ${FIG_ASCII}
          figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Ascii Art"
        fi
        sleep ${delay}
      }
      first=
    }
    clear
    show_ascii ${art}
    [ $? -eq 3 ] || sleep ${delay}
  done
  clear
  [ "${quiet}" ] || {
    printf "\n\n\n\n\n\n"
    if [ "${have_lolcat}" ]
    then
      figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Thanks For" | lolcat
      printf "\n\n"
      figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Watching !" | lolcat
    else
      figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Thanks For"
      printf "\n\n"
      figlet -c -d "${FIG_FONTS}" -f "${SLIDE_FONT}" -k -t "Watching !"
    fi
    sleep ${delay}
  }
  tput cnorm
  [ "${playing}" ] && fade_audio
  exit 0
}

[ ${numtabs} -gt 0 ] && set_tabs

if [ "${height}" ] && [ "${width}" ]
then
  size="--size=${width}x${height}"
else
  if [ "${height}" ] || [ "${width}" ]
  then
    [ "${height}" ] && size="--height=${height}"
    [ "${width}" ] && size="--width=${width}"
  fi
fi

[ "${randfont}" ] && {
  # Arrays with font names
  largefonts=("Bolger" "sblood" "Slant" "Shadow" "Speed" "Varsity")
  smallfonts=("Small" "Small Script" "Small Shadow" "Small Slant")

  # Seed random generator
  RANDOM=$$$(date +%s)

  LARGE_FONT=${largefonts[ $RANDOM % ${#largefonts[@]} ]}
  [ -r "${FIG_FONTS}/${LARGE_FONT}.flf" ] || LARGE_FONT="Standard"
  SMALL_FONT=${smallfonts[ $RANDOM % ${#smallfonts[@]} ]}
  [ -r "${FIG_FONTS}/${SMALL_FONT}.flf" ] || SMALL_FONT="Standard"
}

clear
[ "${quiet}" ] || {
  figlet -c -d "${FIG_FONTS}" -f "${SMALL_FONT}" -k -t ${FIG_WELCOME}
  figlet -c -d "${FIG_FONTS}" -f "${SMALL_FONT}" -k -t ${FIG_ASCII}
  sleep ${delay}
}

if [ "${input_image}" ]
then
  image_name=`basename "${input_image}"`
  suf=`echo ${image_name} | awk -F '.' ' { print $NF } '`
  image_name=`echo ${image_name} | sed -e "s/.${suf}//"`
  if [ "${suf}" == "txt" ]
  then
    cp "${input_image}" "/tmp/${image_name}$$.txt"
  else
    [ "${suf}" == "jpg" ] || \
    [ "${suf}" == "jpeg" ] || \
    [ "${suf}" == "JPG" ] ||
    [ "${suf}" == "JPEG" ] || {
      if [ "${have_convert}" ]
      then
          convert "${input_image}" /tmp/${image_name}$$.jpg
      else
          echo "The 'convert' command is not installed or not in PATH"
          echo "Cannot convert ${input_image} to ascii art"
          exit 1
      fi
    }
    [ -f /tmp/${image_name}$$.jpg ] || {
      cp "${input_image}" /tmp/${image_name}$$.jpg
    }
    # FYI, to get an image width: identify -format "%w" yinyang.jpg
    jp2a ${border} ${colors} ${colordepth} ${grayscale} ${size} ${charopt} \
         --output=/tmp/"${image_name}"$$.txt "/tmp/${image_name}$$.jpg"
  fi
  show_ascii "/tmp/${image_name}$$.txt" "${tabs}"
else
  show_ascii "${ART_DIR}/${art}.txt" "${tabs}"
fi

[ "${quiet}" ] || {
  sleep ${delay}
  if [ "${have_lolcat}" ]
  then
    figlet -c -d "${FIG_FONTS}" -f "${LARGE_FONT}" -k -t ${FIG_WELCOME} | lolcat
    figlet -c -d "${FIG_FONTS}" -f "${LARGE_FONT}" -k -t ${FIG_ASCII} | lolcat
  fi
}

if [ "${have_lolcat}" ]
then
  sleep ${delay}
  if [ "${input_image}" ]
  then
    show_ascii "/tmp/${image_name}$$.txt" "${tabs}" lolcat
  else
    show_ascii "${ART_DIR}/${art}.txt" "${tabs}" lolcat
  fi
fi

[ -f "/tmp/${image_name}$$.txt" ] && {
  if [ "${save_art}" ]
  then
    if [ -f "${ART_DIR}/${image_name}.txt" ]
    then
      if [ "${overwrite}" ]
      then
        sudo cp "/tmp/${image_name}$$.txt" "${ART_DIR}/${image_name}.txt"
      else
        echo "${ART_DIR}/${image_name}.txt already exists"
        echo "Not saving ${image_name}.txt"
      fi
    else
      sudo cp "/tmp/${image_name}$$.txt" "${ART_DIR}/${image_name}.txt"
    fi
  fi
  rm -f "/tmp/${image_name}$$.txt"
}

